# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        
        def traversal(root: TreeNode, nums : list):
            
            if root==None:
                nums.append(None)
                return nums
            
            else:
                nums.append(root.val)
                traversal(root.left,nums)
                traversal(root.right,nums)
                
                return nums
        def subtree(root: TreeNode, sub: list):
            
            if root==None:
                return False
            
            elif root.val==sub[0]:
                left = subtree(root.left,sub)
                right = subtree(root.right, sub)
                
                return sub == traversal(root,[]) or left or right
            
            else:
                left = subtree(root.left,sub)
                right = subtree(root.right,sub)
                
                return left or right
            
        sub = traversal(t,[])
        
        return subtree(s,sub)
        
        
class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        if root: 
            return self.isSameTree(root, subRoot) or self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
        else: 
            return subRoot is None
    
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:  #LC100: https://leetcode.com/problems/same-tree/
        if q is None and p is None: 
            return True
        elif q is None and p is not None: 
            return False
        elif q is not None and p is None: 
            return False
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 
